package datasource

import (
	"io"
	"io/fs"
	"path/filepath"
	"reflect"
	"testing/fstest"

	"github.com/grafana/grafana/internal/cuectx"
	"github.com/grafana/grafana/pkg/schema"
	"github.com/grafana/thema"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
)

func init() {
	lib := cuectx.ProvideThemaLibrary()
	lin, err := DatasourceLineage(lib)
	if err != nil {
		panic(err)
	}

	// Calling this ensures our program cannot start if the Go DataSource.Model type
	// is not aligned with the canonical schema version in our lineage
	_ = newDataSourceJSONKernel(lin)

	zsch, _ := lin.Schema(thema.SV(0, 0))
	if err = thema.AssignableTo(zsch, Model{}); err != nil {
		panic(err)
	}

	sch := schema.NewThemaSchema(lin, &CR{}, &CRList{})
	schema.RegisterCoreSchema(&sch)
}

// CR is the Kubernetes-style CustomResource representation of the DataSource model.
type CR struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   Model       `json:"spec,omitempty"`
	Status ModelStatus `json:"status,omitempty"`
}

// Model is the canonical Go representation of a Grafana datasource. It is
// derived from the datasource Thema lineage.
type Model struct {
	// Omitting these two at least for now, because sequential IDs == :(
	// Id                int64                  `json:"id"`
	// OrgId int64 `json:"orgId"` // May change, but to make store work

	//UID               string `json:"uid"` // May change, but to make store work
	//Name              string `json:"name"`
	Type              string `json:"type"`
	TypeLogoUrl       string `json:"typeLogoUrl"`
	Access            string `json:"access"` // enum: *"proxy" | "direct"
	Url               string `json:"url"`
	Password          string `json:"password"`
	User              string `json:"user"`
	Database          string `json:"database"`
	BasicAuth         bool   `json:"basicAuth"`
	BasicAuthUser     string `json:"basicAuthUser"`
	BasicAuthPassword string `json:"basicAuthPassword"`
	WithCredentials   bool   `json:"withCredentials,omitempty"`
	IsDefault         bool   `json:"isDefault"`
	// JsonData          *simplejson.Json       `json:"jsonData,omitempty"`
	JsonData         map[string]interface{} `json:"jsonData,omitempty"`
	SecureJsonFields map[string]bool        `json:"secureJsonFields,omitempty"`
	Version          int                    `json:"version"`
	ReadOnly         bool                   `json:"readOnly"`
	// AccessControl     accesscontrol.Metadata `json:"accessControl,omitempty"`
	AccessControl map[string]bool `json:"accessControl,omitempty"`
}

// TODO this should be generated by thema
type ModelStatus struct {
	// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster
}

// TODO this should be generated by thema
func (in *CR) DeepCopyObject() runtime.Object {
	val := reflect.ValueOf(in).Elem()

	cpy := reflect.New(val.Type())
	cpy.Elem().Set(val)

	// This might panic, so consider adding `recover` and stuff.
	return cpy.Interface().(runtime.Object)
}

// TODO this should be generated by thema
type CRList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []CR `json:"items"`
}

func (in *CRList) DeepCopyObject() runtime.Object {
	panic("not implemented")
}

func prefixWithGrafanaCUE(prefix string, inputfs fs.FS) (fs.FS, error) {
	m := fstest.MapFS{
		filepath.Join("cue.mod", "module.cue"): &fstest.MapFile{Data: []byte(`module: "github.com/grafana/grafana"`)},
	}

	prefix = filepath.FromSlash(prefix)
	err := fs.WalkDir(inputfs, ".", (func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if d.IsDir() {
			return nil
		}

		f, err := inputfs.Open(path)
		if err != nil {
			return err
		}

		b, err := io.ReadAll(f)
		if err != nil {
			return err
		}

		m[filepath.Join(prefix, path)] = &fstest.MapFile{Data: []byte(b)}
		return nil
	}))

	return m, err
}
